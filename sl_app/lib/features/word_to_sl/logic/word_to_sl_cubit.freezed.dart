// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'word_to_sl_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$WordToSlStateTearOff {
  const _$WordToSlStateTearOff();

  WordToSlInitial initial() {
    return const WordToSlInitial();
  }

  WordToSlLoaded loaded() {
    return const WordToSlLoaded();
  }

  WordToSlWordLoaded wordloaded(String word, String letter, int i) {
    return WordToSlWordLoaded(
      word,
      letter,
      i,
    );
  }

  WordToSlError error({String? error, int? code}) {
    return WordToSlError(
      error: error,
      code: code,
    );
  }
}

/// @nodoc
const $WordToSlState = _$WordToSlStateTearOff();

/// @nodoc
mixin _$WordToSlState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loaded,
    required TResult Function(String word, String letter, int i) wordloaded,
    required TResult Function(String? error, int? code) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loaded,
    TResult Function(String word, String letter, int i)? wordloaded,
    TResult Function(String? error, int? code)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WordToSlInitial value) initial,
    required TResult Function(WordToSlLoaded value) loaded,
    required TResult Function(WordToSlWordLoaded value) wordloaded,
    required TResult Function(WordToSlError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WordToSlInitial value)? initial,
    TResult Function(WordToSlLoaded value)? loaded,
    TResult Function(WordToSlWordLoaded value)? wordloaded,
    TResult Function(WordToSlError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WordToSlStateCopyWith<$Res> {
  factory $WordToSlStateCopyWith(
          WordToSlState value, $Res Function(WordToSlState) then) =
      _$WordToSlStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$WordToSlStateCopyWithImpl<$Res>
    implements $WordToSlStateCopyWith<$Res> {
  _$WordToSlStateCopyWithImpl(this._value, this._then);

  final WordToSlState _value;
  // ignore: unused_field
  final $Res Function(WordToSlState) _then;
}

/// @nodoc
abstract class $WordToSlInitialCopyWith<$Res> {
  factory $WordToSlInitialCopyWith(
          WordToSlInitial value, $Res Function(WordToSlInitial) then) =
      _$WordToSlInitialCopyWithImpl<$Res>;
}

/// @nodoc
class _$WordToSlInitialCopyWithImpl<$Res>
    extends _$WordToSlStateCopyWithImpl<$Res>
    implements $WordToSlInitialCopyWith<$Res> {
  _$WordToSlInitialCopyWithImpl(
      WordToSlInitial _value, $Res Function(WordToSlInitial) _then)
      : super(_value, (v) => _then(v as WordToSlInitial));

  @override
  WordToSlInitial get _value => super._value as WordToSlInitial;
}

/// @nodoc
class _$WordToSlInitial implements WordToSlInitial {
  const _$WordToSlInitial();

  @override
  String toString() {
    return 'WordToSlState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is WordToSlInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loaded,
    required TResult Function(String word, String letter, int i) wordloaded,
    required TResult Function(String? error, int? code) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loaded,
    TResult Function(String word, String letter, int i)? wordloaded,
    TResult Function(String? error, int? code)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WordToSlInitial value) initial,
    required TResult Function(WordToSlLoaded value) loaded,
    required TResult Function(WordToSlWordLoaded value) wordloaded,
    required TResult Function(WordToSlError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WordToSlInitial value)? initial,
    TResult Function(WordToSlLoaded value)? loaded,
    TResult Function(WordToSlWordLoaded value)? wordloaded,
    TResult Function(WordToSlError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class WordToSlInitial implements WordToSlState {
  const factory WordToSlInitial() = _$WordToSlInitial;
}

/// @nodoc
abstract class $WordToSlLoadedCopyWith<$Res> {
  factory $WordToSlLoadedCopyWith(
          WordToSlLoaded value, $Res Function(WordToSlLoaded) then) =
      _$WordToSlLoadedCopyWithImpl<$Res>;
}

/// @nodoc
class _$WordToSlLoadedCopyWithImpl<$Res>
    extends _$WordToSlStateCopyWithImpl<$Res>
    implements $WordToSlLoadedCopyWith<$Res> {
  _$WordToSlLoadedCopyWithImpl(
      WordToSlLoaded _value, $Res Function(WordToSlLoaded) _then)
      : super(_value, (v) => _then(v as WordToSlLoaded));

  @override
  WordToSlLoaded get _value => super._value as WordToSlLoaded;
}

/// @nodoc
class _$WordToSlLoaded implements WordToSlLoaded {
  const _$WordToSlLoaded();

  @override
  String toString() {
    return 'WordToSlState.loaded()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is WordToSlLoaded);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loaded,
    required TResult Function(String word, String letter, int i) wordloaded,
    required TResult Function(String? error, int? code) error,
  }) {
    return loaded();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loaded,
    TResult Function(String word, String letter, int i)? wordloaded,
    TResult Function(String? error, int? code)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WordToSlInitial value) initial,
    required TResult Function(WordToSlLoaded value) loaded,
    required TResult Function(WordToSlWordLoaded value) wordloaded,
    required TResult Function(WordToSlError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WordToSlInitial value)? initial,
    TResult Function(WordToSlLoaded value)? loaded,
    TResult Function(WordToSlWordLoaded value)? wordloaded,
    TResult Function(WordToSlError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class WordToSlLoaded implements WordToSlState {
  const factory WordToSlLoaded() = _$WordToSlLoaded;
}

/// @nodoc
abstract class $WordToSlWordLoadedCopyWith<$Res> {
  factory $WordToSlWordLoadedCopyWith(
          WordToSlWordLoaded value, $Res Function(WordToSlWordLoaded) then) =
      _$WordToSlWordLoadedCopyWithImpl<$Res>;
  $Res call({String word, String letter, int i});
}

/// @nodoc
class _$WordToSlWordLoadedCopyWithImpl<$Res>
    extends _$WordToSlStateCopyWithImpl<$Res>
    implements $WordToSlWordLoadedCopyWith<$Res> {
  _$WordToSlWordLoadedCopyWithImpl(
      WordToSlWordLoaded _value, $Res Function(WordToSlWordLoaded) _then)
      : super(_value, (v) => _then(v as WordToSlWordLoaded));

  @override
  WordToSlWordLoaded get _value => super._value as WordToSlWordLoaded;

  @override
  $Res call({
    Object? word = freezed,
    Object? letter = freezed,
    Object? i = freezed,
  }) {
    return _then(WordToSlWordLoaded(
      word == freezed
          ? _value.word
          : word // ignore: cast_nullable_to_non_nullable
              as String,
      letter == freezed
          ? _value.letter
          : letter // ignore: cast_nullable_to_non_nullable
              as String,
      i == freezed
          ? _value.i
          : i // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
class _$WordToSlWordLoaded implements WordToSlWordLoaded {
  const _$WordToSlWordLoaded(this.word, this.letter, this.i);

  @override
  final String word;
  @override
  final String letter;
  @override
  final int i;

  @override
  String toString() {
    return 'WordToSlState.wordloaded(word: $word, letter: $letter, i: $i)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WordToSlWordLoaded &&
            (identical(other.word, word) ||
                const DeepCollectionEquality().equals(other.word, word)) &&
            (identical(other.letter, letter) ||
                const DeepCollectionEquality().equals(other.letter, letter)) &&
            (identical(other.i, i) ||
                const DeepCollectionEquality().equals(other.i, i)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(word) ^
      const DeepCollectionEquality().hash(letter) ^
      const DeepCollectionEquality().hash(i);

  @JsonKey(ignore: true)
  @override
  $WordToSlWordLoadedCopyWith<WordToSlWordLoaded> get copyWith =>
      _$WordToSlWordLoadedCopyWithImpl<WordToSlWordLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loaded,
    required TResult Function(String word, String letter, int i) wordloaded,
    required TResult Function(String? error, int? code) error,
  }) {
    return wordloaded(word, letter, i);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loaded,
    TResult Function(String word, String letter, int i)? wordloaded,
    TResult Function(String? error, int? code)? error,
    required TResult orElse(),
  }) {
    if (wordloaded != null) {
      return wordloaded(word, letter, i);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WordToSlInitial value) initial,
    required TResult Function(WordToSlLoaded value) loaded,
    required TResult Function(WordToSlWordLoaded value) wordloaded,
    required TResult Function(WordToSlError value) error,
  }) {
    return wordloaded(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WordToSlInitial value)? initial,
    TResult Function(WordToSlLoaded value)? loaded,
    TResult Function(WordToSlWordLoaded value)? wordloaded,
    TResult Function(WordToSlError value)? error,
    required TResult orElse(),
  }) {
    if (wordloaded != null) {
      return wordloaded(this);
    }
    return orElse();
  }
}

abstract class WordToSlWordLoaded implements WordToSlState {
  const factory WordToSlWordLoaded(String word, String letter, int i) =
      _$WordToSlWordLoaded;

  String get word => throw _privateConstructorUsedError;
  String get letter => throw _privateConstructorUsedError;
  int get i => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WordToSlWordLoadedCopyWith<WordToSlWordLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WordToSlErrorCopyWith<$Res> {
  factory $WordToSlErrorCopyWith(
          WordToSlError value, $Res Function(WordToSlError) then) =
      _$WordToSlErrorCopyWithImpl<$Res>;
  $Res call({String? error, int? code});
}

/// @nodoc
class _$WordToSlErrorCopyWithImpl<$Res>
    extends _$WordToSlStateCopyWithImpl<$Res>
    implements $WordToSlErrorCopyWith<$Res> {
  _$WordToSlErrorCopyWithImpl(
      WordToSlError _value, $Res Function(WordToSlError) _then)
      : super(_value, (v) => _then(v as WordToSlError));

  @override
  WordToSlError get _value => super._value as WordToSlError;

  @override
  $Res call({
    Object? error = freezed,
    Object? code = freezed,
  }) {
    return _then(WordToSlError(
      error: error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
class _$WordToSlError implements WordToSlError {
  const _$WordToSlError({this.error, this.code});

  @override
  final String? error;
  @override
  final int? code;

  @override
  String toString() {
    return 'WordToSlState.error(error: $error, code: $code)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WordToSlError &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(code);

  @JsonKey(ignore: true)
  @override
  $WordToSlErrorCopyWith<WordToSlError> get copyWith =>
      _$WordToSlErrorCopyWithImpl<WordToSlError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loaded,
    required TResult Function(String word, String letter, int i) wordloaded,
    required TResult Function(String? error, int? code) error,
  }) {
    return error(this.error, code);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loaded,
    TResult Function(String word, String letter, int i)? wordloaded,
    TResult Function(String? error, int? code)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error, code);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WordToSlInitial value) initial,
    required TResult Function(WordToSlLoaded value) loaded,
    required TResult Function(WordToSlWordLoaded value) wordloaded,
    required TResult Function(WordToSlError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WordToSlInitial value)? initial,
    TResult Function(WordToSlLoaded value)? loaded,
    TResult Function(WordToSlWordLoaded value)? wordloaded,
    TResult Function(WordToSlError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class WordToSlError implements WordToSlState {
  const factory WordToSlError({String? error, int? code}) = _$WordToSlError;

  String? get error => throw _privateConstructorUsedError;
  int? get code => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WordToSlErrorCopyWith<WordToSlError> get copyWith =>
      throw _privateConstructorUsedError;
}
